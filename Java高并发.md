# Java 高并发

volatile 在一个项目中遇到这个用法，这个项目是一个config包。可以用来存放配置，也可以用来做灰度部署。 总之来说还是很强大，以前的公司我们这些都是
自己做，现在在大公司里这些功能都有专人负责，感觉省了很多事情。

## volatile

- volatile关键字是与Java的内存模型有关的
- 在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存
- 缓存一致性问题。通常称这种被多个线程访问的变量为共享变量
- JVM 指令重排序
- Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存
- 对于可见性，Java提供了volatile关键字来保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。
- 在Java里面，可以通过volatile关键字来保证一定的“有序性”

```java
//线程1
boolean stop = false;
while(!stop){
    doSomething();
}
 
//线程2
stop = true;
```
　
这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。
那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。

但是用volatile修饰之后就变得不一样了：

第一：使用volatile关键字会强制将修改的值立即写入主存；
第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；
第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。
