# Java知识点整理
java 水平还不够，经常出现错误后看到源码是看不下去，因为有些语法还不够熟悉，异常栈不够熟悉等。
需要多练习看源码，多熟悉各种语法，多熟悉看log，看异常栈

我现在一遇到异常，尤其是别人的代码的异常时，经常就束手无策，本质原因是因为对java不熟，看到很深的异常栈，看到出错是别人的代码就完全不会
追踪错误的根源。尤其是很多底层的代码使用的语法结构比较复杂，我都很排斥，一看到一长串深深的异常栈第一反应都有点恐惧和不适。。。 不愿意去阅读，结果就导致代码阅读能力很差，一直没有进步。

以后要多练习阅读源码，熟悉各种语法，各种常用的库，熟悉sprintboot。 
不说别的，最起码先把java玩熟吧。

感觉学习java要像学习英语一样，必须要大量的使用，多读，多写，不懂的就查，慢慢的日积月累就成长起来了。

## thymeleaf模板引擎
在做patrolman的时候遇到的这个用法，不知道是做什么的，所以了解一下

模板引擎（Template Engine）, 是用来解析对应类型模板文件然后动态生成由数据和静态页面组成的视图文件的一个工具。 它通过标签(tag)来响应各种解析动作，通过变量占位的方式动态的将对应数据展示到指定位置。



## Java 抽象方法
而抽象方法，是指没有方法体的方法，同时抽象方法还必须使用关键字abstract做修饰。

接口不能包含成员变量，除了 static 和 final 变量。

函数式接口中除了那个抽象方法外还可以包含静态方法。
Java 8以前的规范中接口中不允许定义静态方法。 静态方法只能在类中定义。 Java 8中可以定义静态方法。

Java 8中允许接口实现方法， 而不是简单的声明， 这些方法叫做默认方法，使用特殊的关键字default。
因为默认方法不是抽象方法，所以不影响我们判断一个接口是否是函数式接口。



## Interface 里面可以定义函数

## FunctionalInterface
java8的新特性，函数式接口，函数式接口实例的创建有三种方式：1、lambda表达式；2、方法引用；3、构造方法引用。

常见的函数式接口有
  Function<T,R>   

  接收一个T类型的参数，返回一个R类型的结果

  Consumer<T>

  接收一个T类型的参数，不返回值

  Predicate<T>

  接收一个T类型的参数，返回一个boolean类型的结果

  Supplier<T>

  不接受参数，返回一个T类型的结果



## 学习java异常


- 异常栈以FILO的顺序打印，位于打印内容最下方的异常最早被抛出，逐渐导致上方异常被抛出
- 异常栈中每个异常都由异常名+细节信息+路径组成
- 路径以FIFO的顺序打印，位于打印内容最上方的位置最早被该异常经过，逐层向外抛出

## Idea使用
在调试一个小项目时，debug的时候突然发现项目启动特别慢。一开始不知道什么原因。
网上查了一下才发现是因为加了一类断点，叫做Java Method Breakpoints 的。如果有这一类的断点就会启动特别的慢。

## 静态内部类
今天在看别人代码的时候学到一个写法，在dto类内部定义static class，这种静态内部类是作为数据的一个子结构，只在dto内部
才会用到，这种写法不要建立更多的数据类，使包结构变得简单。 而之所以使用静态内部类是因为非静态内部类的创建需要依赖外部类
而且也可以访问外部类的全部内容，而静态内部类就不可以访问，同时创建也是独立的。 一个很好的比方
类 + 静态内部类 = 熟鸡蛋 （壳破了，里面依然正常）
类 + 非静态内部类 = 生鸡蛋 （壳破了，里面也碎了）

## 注解
注解之前用的不多，而且也没有深入了解过它的原理
注解，metadata，可以在编译，类加载，运行的时候被读取，并执行相应的一些处理。


一定程度上。 框架 = 注解 + 反射 + 设计模式

元注解

元标签有 @Retention、@Documented、@Target、@Inherited、@Repeatable 5 种。


1. 类型一 生成文档相关的注解

- author
- version
- return
-exception


2. 类型二 在编译时进行格式检查 jdk内置的三个基本注解

- override

- deprecated

- supresswarning


3. 类型三 跟踪代码依赖性，实现替代配置文件的功能

- servlet 里面的配置

- spring 里面的trasaction配置


- Retention注解

一些关键字

- volatile

- static synchronized

4. 注解与xml


5. alias注解的别名

不仅是一个注解内不同属性可以声明别名，不同注解的属性也可以声明别名（注解可以作用于注解）



## java 新特性

java8 default 
- 默认方法
- 注解的默认值

自定义注解只有一个属性时，且属性名为value时，赋值时value可省略



